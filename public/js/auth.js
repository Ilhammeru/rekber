/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/auth.js":
/*!******************************!*\
  !*** ./resources/js/auth.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("var _require = __webpack_require__(/*! easytimer.js */ \"./node_modules/easytimer.js/dist/easytimer.js\"),\n  Timer = _require[\"default\"];\n$('#btn-register').click(function (e) {\n  e.preventDefault();\n  var form = $('#form-register').serialize();\n  $.ajax({\n    type: 'POST',\n    url: app_url + '/register',\n    data: form,\n    beforeSend: function beforeSend() {\n      toggleLoading(true, i18n.global.processing);\n      removeValidation('form-register');\n    },\n    success: function success(res) {\n      toggleLoading(false);\n      responseUrl(res.data.url);\n    },\n    error: function error(err) {\n      handleError(err);\n      toggleLoading(false);\n    }\n  });\n});\n\n/**\n * Function to send OTP via whatsapp\n */\nvar sendOtp = function sendOtp(phone) {\n  $.ajax({\n    type: 'POST',\n    url: app_url + '/otp/send',\n    data: {\n      phone: phone\n    },\n    beforeSend: function beforeSend() {\n      toggleLoading(true, i18n.global.sending);\n      $('#send-otp-whatsapp-btn').prop('disabled', true);\n    },\n    success: function success(res) {\n      toggleLoading(false);\n      $('#row-otp-whatsapp').removeClass('d-none');\n      $('#btn-submit-otp').prop('disabled', false);\n      $('#send-otp-whatsapp-btn').prop('disabled', true);\n      setupTimer(60);\n    },\n    error: function error(err) {\n      console.log('err', err);\n      $('#send-otp-whatsapp-btn').prop('disabled', false);\n      toggleLoading(false);\n      handleError(err);\n    }\n  });\n};\nvar verifiedEmailOtp = function verifiedEmailOtp() {\n  var email = $('#form-otp #helper').val();\n  $.ajax({\n    type: 'POST',\n    url: app_url + '/register/otp/' + email,\n    data: {\n      otp: $('#form-otp #otp').val()\n    },\n    beforeSend: function beforeSend() {\n      toggleLoading(true, i18n.global.processing);\n      removeValidation('form-otp');\n    },\n    success: function success(res) {\n      toggleLoading(false);\n      handleSuccess(res.message);\n      responseUrl(res.data.url, 1500);\n    },\n    error: function error(err) {\n      toggleLoading(false);\n      handleError(err);\n    }\n  });\n};\nvar verifiedPhoneOtp = function verifiedPhoneOtp() {\n  $.ajax({\n    type: 'POST',\n    url: app_url + '/otp/whatsapp/validate',\n    data: {\n      email: $('#helper').val(),\n      otp: $('#otp').val()\n    },\n    beforeSend: function beforeSend() {\n      toggleLoading(true, i18n.global.processing);\n      removeValidation('form-otp-whatsapp');\n    },\n    success: function success(res) {\n      toggleLoading(false);\n      handleSuccess(res.message);\n      responseUrl(res.data.url, 1500);\n    },\n    error: function error(err) {\n      toggleLoading(false);\n      handleError(err);\n    }\n  });\n};\nvar setupTimer = function setupTimer(seconds) {\n  var timer = new Timer({\n    countdown: true\n  });\n  timer.start({\n    startValues: {\n      seconds: seconds\n    },\n    target: {\n      seconds: 0\n    }\n  });\n  $('#send-otp-whatsapp-btn').html(timer.getTimeValues().toString());\n  timer.addEventListener('secondsUpdated', function (e) {\n    $('#send-otp-whatsapp-btn').html(timer.getTimeValues().toString());\n  });\n  timer.addEventListener('targetAchieved', function (e) {\n    $('#send-otp-whatsapp-btn').prop('disabled', false);\n    $('#send-otp-whatsapp-btn').text(i18n.global.send + ' ' + i18n.global.otp);\n  });\n};\nwindow.setupTimer = setupTimer;\nwindow.sendOtp = sendOtp;\nwindow.verifiedPhoneOtp = verifiedPhoneOtp;\nwindow.verifiedEmailOtp = verifiedEmailOtp;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxRQUFRLENBQUMsQ0FBQyxDQUFDO0VBQ3RFLENBQUMsQ0FBQztFQUVGUCxLQUFLLENBQUNRLGdCQUFnQixDQUFDLGdCQUFnQixFQUFFLFVBQVU3QyxDQUFDLEVBQUU7SUFDbERGLENBQUMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDMEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxLQUFLLENBQUM7SUFDbkQxQixDQUFDLENBQUMsd0JBQXdCLENBQUMsQ0FBQ2dELElBQUksQ0FBQ25DLElBQUksQ0FBQ0MsTUFBTSxDQUFDbUMsSUFBSSxHQUFHLEdBQUcsR0FBR3BDLElBQUksQ0FBQ0MsTUFBTSxDQUFDb0IsR0FBRyxDQUFDO0VBQzlFLENBQUMsQ0FBQztBQUNOLENBQUM7QUFFRGdCLE1BQU0sQ0FBQ3RCLFVBQVUsR0FBR0EsVUFBVTtBQUM5QnNCLE1BQU0sQ0FBQzNCLE9BQU8sR0FBR0EsT0FBTztBQUN4QjJCLE1BQU0sQ0FBQ2IsZ0JBQWdCLEdBQUdBLGdCQUFnQjtBQUMxQ2EsTUFBTSxDQUFDbkIsZ0JBQWdCLEdBQUdBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9hdXRoLmpzP2E3NzMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBkZWZhdWx0OiBUaW1lciB9ID0gcmVxdWlyZShcImVhc3l0aW1lci5qc1wiKTtcblxuXG5cbiQoJyNidG4tcmVnaXN0ZXInKS5jbGljaygoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGxldCBmb3JtID0gJCgnI2Zvcm0tcmVnaXN0ZXInKS5zZXJpYWxpemUoKTtcbiAgICAkLmFqYXgoe1xuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIHVybDogYXBwX3VybCArICcvcmVnaXN0ZXInLFxuICAgICAgICBkYXRhOiBmb3JtLFxuICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0b2dnbGVMb2FkaW5nKHRydWUsIGkxOG4uZ2xvYmFsLnByb2Nlc3NpbmcpO1xuICAgICAgICAgICAgcmVtb3ZlVmFsaWRhdGlvbignZm9ybS1yZWdpc3RlcicpO1xuICAgICAgICB9LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB0b2dnbGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJlc3BvbnNlVXJsKHJlcy5kYXRhLnVybCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICAgICAgdG9nZ2xlTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KVxufSk7XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gc2VuZCBPVFAgdmlhIHdoYXRzYXBwXG4gKi9cbmNvbnN0IHNlbmRPdHAgPSAocGhvbmUpID0+IHtcbiAgICAkLmFqYXgoe1xuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIHVybDogYXBwX3VybCArICcvb3RwL3NlbmQnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwaG9uZTogcGhvbmUsXG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdG9nZ2xlTG9hZGluZyh0cnVlLCBpMThuLmdsb2JhbC5zZW5kaW5nKTtcbiAgICAgICAgICAgICQoJyNzZW5kLW90cC13aGF0c2FwcC1idG4nKS5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB0b2dnbGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICQoJyNyb3ctb3RwLXdoYXRzYXBwJykucmVtb3ZlQ2xhc3MoJ2Qtbm9uZScpO1xuICAgICAgICAgICAgJCgnI2J0bi1zdWJtaXQtb3RwJykucHJvcCgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICAkKCcjc2VuZC1vdHAtd2hhdHNhcHAtYnRuJykucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIHNldHVwVGltZXIoNjApO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2VycicsZXJyKTtcbiAgICAgICAgICAgICQoJyNzZW5kLW90cC13aGF0c2FwcC1idG4nKS5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgIHRvZ2dsZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmNvbnN0IHZlcmlmaWVkRW1haWxPdHAgPSAoKSA9PiB7XG4gICAgbGV0IGVtYWlsID0gJCgnI2Zvcm0tb3RwICNoZWxwZXInKS52YWwoKTtcbiAgICAkLmFqYXgoe1xuICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgIHVybDogYXBwX3VybCArICcvcmVnaXN0ZXIvb3RwLycgKyBlbWFpbCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgb3RwOiAkKCcjZm9ybS1vdHAgI290cCcpLnZhbCgpLFxuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVTZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0b2dnbGVMb2FkaW5nKHRydWUsIGkxOG4uZ2xvYmFsLnByb2Nlc3NpbmcpO1xuICAgICAgICAgICAgcmVtb3ZlVmFsaWRhdGlvbignZm9ybS1vdHAnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgdG9nZ2xlTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBoYW5kbGVTdWNjZXNzKHJlcy5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJlc3BvbnNlVXJsKHJlcy5kYXRhLnVybCwgMTUwMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0b2dnbGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9KVxufVxuXG5jb25zdCB2ZXJpZmllZFBob25lT3RwID0gKCkgPT4ge1xuICAgICQuYWpheCh7XG4gICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgdXJsOiBhcHBfdXJsICsgJy9vdHAvd2hhdHNhcHAvdmFsaWRhdGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBlbWFpbDogJCgnI2hlbHBlcicpLnZhbCgpLFxuICAgICAgICAgICAgb3RwOiAkKCcjb3RwJykudmFsKCksXG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZVNlbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRvZ2dsZUxvYWRpbmcodHJ1ZSwgaTE4bi5nbG9iYWwucHJvY2Vzc2luZyk7XG4gICAgICAgICAgICByZW1vdmVWYWxpZGF0aW9uKCdmb3JtLW90cC13aGF0c2FwcCcpO1xuICAgICAgICB9LFxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICB0b2dnbGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGhhbmRsZVN1Y2Nlc3MocmVzLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVzcG9uc2VVcmwocmVzLmRhdGEudXJsLCAxNTAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRvZ2dsZUxvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0pXG59XG5cbmNvbnN0IHNldHVwVGltZXIgPSAoc2Vjb25kcykgPT4ge1xuICAgIHZhciB0aW1lciA9IG5ldyBUaW1lcih7XG4gICAgICAgIGNvdW50ZG93bjogdHJ1ZSxcbiAgICB9KTtcbiAgICB0aW1lci5zdGFydCh7XG4gICAgICAgIHN0YXJ0VmFsdWVzOiB7XG4gICAgICAgICAgICBzZWNvbmRzOiBzZWNvbmRzLFxuICAgICAgICB9LFxuICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIHNlY29uZHM6IDAsXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAkKCcjc2VuZC1vdHAtd2hhdHNhcHAtYnRuJykuaHRtbCh0aW1lci5nZXRUaW1lVmFsdWVzKCkudG9TdHJpbmcoKSk7XG5cbiAgICB0aW1lci5hZGRFdmVudExpc3RlbmVyKCdzZWNvbmRzVXBkYXRlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICQoJyNzZW5kLW90cC13aGF0c2FwcC1idG4nKS5odG1sKHRpbWVyLmdldFRpbWVWYWx1ZXMoKS50b1N0cmluZygpKTtcbiAgICB9KTtcblxuICAgIHRpbWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcmdldEFjaGlldmVkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgJCgnI3NlbmQtb3RwLXdoYXRzYXBwLWJ0bicpLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAkKCcjc2VuZC1vdHAtd2hhdHNhcHAtYnRuJykudGV4dChpMThuLmdsb2JhbC5zZW5kICsgJyAnICsgaTE4bi5nbG9iYWwub3RwKTtcbiAgICB9KTtcbn1cblxud2luZG93LnNldHVwVGltZXIgPSBzZXR1cFRpbWVyO1xud2luZG93LnNlbmRPdHAgPSBzZW5kT3RwO1xud2luZG93LnZlcmlmaWVkUGhvbmVPdHAgPSB2ZXJpZmllZFBob25lT3RwO1xud2luZG93LnZlcmlmaWVkRW1haWxPdHAgPSB2ZXJpZmllZEVtYWlsT3RwO1xuIl0sIm5hbWVzIjpbIl9yZXF1aXJlIiwicmVxdWlyZSIsIlRpbWVyIiwiJCIsImNsaWNrIiwiZSIsInByZXZlbnREZWZhdWx0IiwiZm9ybSIsInNlcmlhbGl6ZSIsImFqYXgiLCJ0eXBlIiwidXJsIiwiYXBwX3VybCIsImRhdGEiLCJiZWZvcmVTZW5kIiwidG9nZ2xlTG9hZGluZyIsImkxOG4iLCJnbG9iYWwiLCJwcm9jZXNzaW5nIiwicmVtb3ZlVmFsaWRhdGlvbiIsInN1Y2Nlc3MiLCJyZXMiLCJyZXNwb25zZVVybCIsImVycm9yIiwiZXJyIiwiaGFuZGxlRXJyb3IiLCJzZW5kT3RwIiwicGhvbmUiLCJzZW5kaW5nIiwicHJvcCIsInJlbW92ZUNsYXNzIiwic2V0dXBUaW1lciIsImNvbnNvbGUiLCJsb2ciLCJ2ZXJpZmllZEVtYWlsT3RwIiwiZW1haWwiLCJ2YWwiLCJvdHAiLCJoYW5kbGVTdWNjZXNzIiwibWVzc2FnZSIsInZlcmlmaWVkUGhvbmVPdHAiLCJzZWNvbmRzIiwidGltZXIiLCJjb3VudGRvd24iLCJzdGFydCIsInN0YXJ0VmFsdWVzIiwidGFyZ2V0IiwiaHRtbCIsImdldFRpbWVWYWx1ZXMiLCJ0b1N0cmluZyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0ZXh0Iiwic2VuZCIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/auth.js\n");

/***/ }),

/***/ "./node_modules/easytimer.js/dist/easytimer.js":
/*!*****************************************************!*\
  !*** ./node_modules/easytimer.js/dist/easytimer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * easytimer.js\n * Generated: 2022-08-23\n * Version: 4.5.4\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  0;\n})(this, (function (exports) { 'use strict';\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      enumerableOnly && (symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      })), keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = null != arguments[i] ? arguments[i] : {};\n      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n\n    return target;\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function leftPadding(string, padLength, character) {\n    var i;\n    var characters = '';\n    string = typeof string === 'number' ? String(string) : string;\n\n    if (string.length > padLength) {\n      return string;\n    }\n\n    for (i = 0; i < padLength; i = i + 1) {\n      characters += String(character);\n    }\n\n    return (characters + string).slice(-characters.length);\n  }\n\n  function TimeCounter() {\n    this.reset();\n  }\n  /**\n   * [toString convert the counted values on a string]\n   * @param  {array} units           [array with the units to display]\n   * @param  {string} separator       [separator of the units]\n   * @param  {number} leftZeroPadding [number of zero padding]\n   * @return {string}                 [result string]\n   */\n\n\n  TimeCounter.prototype.toString = function () {\n    var units = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['hours', 'minutes', 'seconds'];\n    var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ':';\n    var leftZeroPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    units = units || ['hours', 'minutes', 'seconds'];\n    separator = separator || ':';\n    leftZeroPadding = leftZeroPadding || 2;\n    var arrayTime = [];\n    var i;\n\n    for (i = 0; i < units.length; i = i + 1) {\n      if (this[units[i]] !== undefined) {\n        if (units[i] === 'secondTenths') {\n          arrayTime.push(this[units[i]]);\n        } else {\n          arrayTime.push(leftPadding(this[units[i]], leftZeroPadding, '0'));\n        }\n      }\n    }\n\n    return arrayTime.join(separator);\n  };\n  /**\n   * [reset reset counter]\n   */\n\n\n  TimeCounter.prototype.reset = function () {\n    this.secondTenths = 0;\n    this.seconds = 0;\n    this.minutes = 0;\n    this.hours = 0;\n    this.days = 0;\n  };\n\n  function EventEmitter() {\n    this.events = {};\n  }\n\n  EventEmitter.prototype.on = function (event, listener) {\n    var _this = this;\n\n    if (!Array.isArray(this.events[event])) {\n      this.events[event] = [];\n    }\n\n    this.events[event].push(listener);\n    return function () {\n      return _this.removeListener(event, listener);\n    };\n  };\n\n  EventEmitter.prototype.removeListener = function (event, listener) {\n    if (Array.isArray(this.events[event])) {\n      var eventIndex = this.events[event].indexOf(listener);\n\n      if (eventIndex > -1) {\n        this.events[event].splice(eventIndex, 1);\n      }\n    }\n  };\n\n  EventEmitter.prototype.removeAllListeners = function (event) {\n    if (!event) {\n      this.events = {};\n    } else if (Array.isArray(this.events[event])) {\n      this.events[event] = [];\n    }\n  };\n\n  EventEmitter.prototype.emit = function (event) {\n    var _this2 = this;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (Array.isArray(this.events[event])) {\n      this.events[event].forEach(function (listener) {\n        return listener.apply(_this2, args);\n      });\n    }\n  };\n\n  /*\n   * General functions, variables and constants\n   */\n\n  var SECOND_TENTHS_PER_SECOND = 10;\n  var SECONDS_PER_MINUTE = 60;\n  var MINUTES_PER_HOUR = 60;\n  var HOURS_PER_DAY = 24;\n  var SECOND_TENTHS_POSITION = 0;\n  var SECONDS_POSITION = 1;\n  var MINUTES_POSITION = 2;\n  var HOURS_POSITION = 3;\n  var DAYS_POSITION = 4;\n  var SECOND_TENTHS = 'secondTenths';\n  var SECONDS = 'seconds';\n  var MINUTES = 'minutes';\n  var HOURS = 'hours';\n  var DAYS = 'days';\n  var VALID_INPUT_VALUES = [SECOND_TENTHS, SECONDS, MINUTES, HOURS, DAYS];\n  var unitsInMilliseconds = {\n    secondTenths: 100,\n    seconds: 1000,\n    minutes: 60000,\n    hours: 3600000,\n    days: 86400000\n  };\n  var groupedUnits = {\n    secondTenths: SECOND_TENTHS_PER_SECOND,\n    seconds: SECONDS_PER_MINUTE,\n    minutes: MINUTES_PER_HOUR,\n    hours: HOURS_PER_DAY\n  };\n\n  function mod(number, module) {\n    return (number % module + module) % module;\n  }\n  /**\n   * [Timer Timer/Chronometer/Countdown compatible with AMD and NodeJS.\n   * Can update time values with different time intervals: tenth of seconds,\n   * seconds, minutes and hours.]\n   */\n\n\n  function Timer() {\n    var defaultParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /*\n    * PRIVATE variables and Functions\n    */\n    var counters = new TimeCounter();\n    var totalCounters = new TimeCounter();\n    var intervalId;\n    var eventEmitter = new EventEmitter();\n    var running = false;\n    var paused = false;\n    var precision;\n    var timerTypeFactor;\n    var customCallback;\n    var timerConfig = {};\n    var currentParams;\n    var targetValues;\n    var startValues;\n    var countdown;\n    var startingDate;\n    var targetDate;\n    var eventData = {\n      detail: {\n        timer: this\n      }\n    };\n    setParams(defaultParams);\n\n    function updateCounters(precision, roundedValue) {\n      var unitsPerGroup = groupedUnits[precision];\n      totalCounters[precision] = roundedValue;\n\n      if (precision === DAYS) {\n        counters[precision] = Math.abs(roundedValue);\n      } else if (roundedValue >= 0) {\n        counters[precision] = mod(roundedValue, unitsPerGroup);\n      } else {\n        counters[precision] = mod(unitsPerGroup - mod(roundedValue, unitsPerGroup), unitsPerGroup);\n      }\n    }\n\n    function updateDays(value) {\n      return updateUnitByPrecision(value, DAYS);\n    }\n\n    function updateHours(value) {\n      return updateUnitByPrecision(value, HOURS);\n    }\n\n    function updateMinutes(value) {\n      return updateUnitByPrecision(value, MINUTES);\n    }\n\n    function updateSeconds(value) {\n      return updateUnitByPrecision(value, SECONDS);\n    }\n\n    function updateSecondTenths(value) {\n      return updateUnitByPrecision(value, SECOND_TENTHS);\n    }\n\n    function updateUnitByPrecision(value, precision) {\n      var previousValue = totalCounters[precision];\n      updateCounters(precision, calculateIntegerUnitQuotient(value, unitsInMilliseconds[precision]));\n      return totalCounters[precision] !== previousValue;\n    }\n\n    function stopTimerAndResetCounters() {\n      stopTimer();\n      resetCounters();\n    }\n\n    function stopTimer() {\n      clearInterval(intervalId);\n      intervalId = undefined;\n      running = false;\n      paused = false;\n    }\n\n    function setParamsAndStartTimer(params) {\n      if (!isPaused()) {\n        setParams(params);\n      } else {\n        startingDate = calculateStartingDate();\n        targetValues = setTarget(currentParams.target);\n      }\n\n      startTimer();\n    }\n\n    function startTimer() {\n      var interval = unitsInMilliseconds[precision];\n\n      if (isTargetAchieved(roundTimestamp(Date.now()))) {\n        return;\n      }\n\n      intervalId = setInterval(updateTimerAndDispatchEvents, interval);\n      running = true;\n      paused = false;\n    }\n\n    function calculateStartingDate() {\n      return roundTimestamp(Date.now()) - totalCounters.secondTenths * unitsInMilliseconds[SECOND_TENTHS] * timerTypeFactor;\n    }\n\n    function updateTimerAndDispatchEvents() {\n      var currentTime = roundTimestamp(Date.now());\n      var valuesUpdated = updateTimer();\n      dispatchEvents(valuesUpdated);\n      customCallback(eventData.detail.timer);\n\n      if (isTargetAchieved(currentTime)) {\n        stop();\n        dispatchEvent('targetAchieved', eventData);\n      }\n    }\n\n    function updateTimer() {\n      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : roundTimestamp(Date.now());\n      var elapsedTime = timerTypeFactor > 0 ? currentTime - startingDate : startingDate - currentTime;\n      var valuesUpdated = {};\n      valuesUpdated[SECOND_TENTHS] = updateSecondTenths(elapsedTime);\n      valuesUpdated[SECONDS] = updateSeconds(elapsedTime);\n      valuesUpdated[MINUTES] = updateMinutes(elapsedTime);\n      valuesUpdated[HOURS] = updateHours(elapsedTime);\n      valuesUpdated[DAYS] = updateDays(elapsedTime);\n      return valuesUpdated;\n    }\n\n    function roundTimestamp(timestamp) {\n      return Math.floor(timestamp / unitsInMilliseconds[precision]) * unitsInMilliseconds[precision];\n    }\n\n    function dispatchEvents(valuesUpdated) {\n      if (valuesUpdated[SECOND_TENTHS]) {\n        dispatchEvent('secondTenthsUpdated', eventData);\n      }\n\n      if (valuesUpdated[SECONDS]) {\n        dispatchEvent('secondsUpdated', eventData);\n      }\n\n      if (valuesUpdated[MINUTES]) {\n        dispatchEvent('minutesUpdated', eventData);\n      }\n\n      if (valuesUpdated[HOURS]) {\n        dispatchEvent('hoursUpdated', eventData);\n      }\n\n      if (valuesUpdated[DAYS]) {\n        dispatchEvent('daysUpdated', eventData);\n      }\n    }\n\n    function isTargetAchieved(currentDate) {\n      return targetValues instanceof Array && currentDate >= targetDate;\n    }\n\n    function resetCounters() {\n      counters.reset();\n      totalCounters.reset();\n    }\n\n    function setParams(params) {\n      params = params || {};\n      precision = checkPrecision(params.precision);\n      customCallback = typeof params.callback === 'function' ? params.callback : function () {};\n      countdown = params.countdown === true;\n      timerTypeFactor = countdown === true ? -1 : 1;\n\n      if (_typeof(params.startValues) === 'object') {\n        setStartValues(params.startValues);\n      } else {\n        startValues = null;\n      }\n\n      startingDate = calculateStartingDate();\n      updateTimer();\n\n      if (_typeof(params.target) === 'object') {\n        targetValues = setTarget(params.target);\n      } else if (countdown) {\n        params.target = {\n          seconds: 0\n        };\n        targetValues = setTarget(params.target);\n      } else {\n        targetValues = null;\n      }\n\n      timerConfig = {\n        precision: precision,\n        callback: customCallback,\n        countdown: _typeof(params) === 'object' && params.countdown === true,\n        target: targetValues,\n        startValues: startValues\n      };\n      currentParams = params;\n    }\n\n    function checkPrecision(precision) {\n      precision = typeof precision === 'string' ? precision : SECONDS;\n\n      if (!isValidInputValue(precision)) {\n        throw new Error(\"Error in precision parameter: \".concat(precision, \" is not a valid value\"));\n      }\n\n      return precision;\n    }\n\n    function isValidInputValue(value) {\n      return VALID_INPUT_VALUES.indexOf(value) >= 0;\n    }\n\n    function configInputValues(inputValues) {\n      var values;\n\n      if (_typeof(inputValues) === 'object') {\n        if (inputValues instanceof Array) {\n          if (inputValues.length !== 5) {\n            throw new Error('Array size not valid');\n          }\n\n          values = inputValues;\n        } else {\n          for (var value in inputValues) {\n            if (VALID_INPUT_VALUES.indexOf(value) < 0) {\n              throw new Error(\"Error in startValues or target parameter: \".concat(value, \" is not a valid input value\"));\n            }\n          }\n\n          values = [inputValues.secondTenths || 0, inputValues.seconds || 0, inputValues.minutes || 0, inputValues.hours || 0, inputValues.days || 0];\n        }\n      }\n\n      values = values.map(function (value) {\n        return parseInt(value, 10);\n      });\n      var secondTenths = values[SECOND_TENTHS_POSITION];\n      var seconds = values[SECONDS_POSITION] + calculateIntegerUnitQuotient(secondTenths, SECOND_TENTHS_PER_SECOND);\n      var minutes = values[MINUTES_POSITION] + calculateIntegerUnitQuotient(seconds, SECONDS_PER_MINUTE);\n      var hours = values[HOURS_POSITION] + calculateIntegerUnitQuotient(minutes, MINUTES_PER_HOUR);\n      var days = values[DAYS_POSITION] + calculateIntegerUnitQuotient(hours, HOURS_PER_DAY);\n      values[SECOND_TENTHS_POSITION] = secondTenths % SECOND_TENTHS_PER_SECOND;\n      values[SECONDS_POSITION] = seconds % SECONDS_PER_MINUTE;\n      values[MINUTES_POSITION] = minutes % MINUTES_PER_HOUR;\n      values[HOURS_POSITION] = hours % HOURS_PER_DAY;\n      values[DAYS_POSITION] = days;\n      return values;\n    }\n\n    function calculateIntegerUnitQuotient(unit, divisor) {\n      var quotient = unit / divisor;\n      return quotient < 0 ? Math.ceil(quotient) : Math.floor(quotient);\n    }\n\n    function setTarget(inputTarget) {\n      if (!inputTarget) {\n        return;\n      }\n\n      targetValues = configInputValues(inputTarget);\n      var targetCounter = calculateTotalCounterFromValues(targetValues);\n      targetDate = startingDate + targetCounter.secondTenths * unitsInMilliseconds[SECOND_TENTHS] * timerTypeFactor;\n      return targetValues;\n    }\n\n    function setStartValues(inputStartValues) {\n      startValues = configInputValues(inputStartValues);\n      counters.secondTenths = startValues[SECOND_TENTHS_POSITION];\n      counters.seconds = startValues[SECONDS_POSITION];\n      counters.minutes = startValues[MINUTES_POSITION];\n      counters.hours = startValues[HOURS_POSITION];\n      counters.days = startValues[DAYS_POSITION];\n      totalCounters = calculateTotalCounterFromValues(startValues, totalCounters);\n    }\n\n    function calculateTotalCounterFromValues(values, outputCounter) {\n      var total = outputCounter || {};\n      total.days = values[DAYS_POSITION];\n      total.hours = total.days * HOURS_PER_DAY + values[HOURS_POSITION];\n      total.minutes = total.hours * MINUTES_PER_HOUR + values[MINUTES_POSITION];\n      total.seconds = total.minutes * SECONDS_PER_MINUTE + values[SECONDS_POSITION];\n      total.secondTenths = total.seconds * SECOND_TENTHS_PER_SECOND + values[[SECOND_TENTHS_POSITION]];\n      return total;\n    }\n    /*\n     * PUBLIC functions\n     */\n\n    /**\n     * [stop stops the timer and resets the counters. Dispatch stopped event]\n     */\n\n\n    function stop() {\n      stopTimerAndResetCounters();\n      dispatchEvent('stopped', eventData);\n    }\n    /**\n     * [stop stops and starts the timer. Dispatch stopped event]\n     */\n\n\n    function reset() {\n      stopTimerAndResetCounters();\n      setParamsAndStartTimer(currentParams);\n      dispatchEvent('reset', eventData);\n    }\n    /**\n     * [start starts the timer configured by the params object. Dispatch started event]\n     * @param  {object} params [Configuration parameters]\n     */\n\n\n    function start() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      params = _objectSpread2(_objectSpread2({}, defaultParams), params);\n\n      if (isRunning()) {\n        return;\n      }\n\n      setParamsAndStartTimer(params);\n      dispatchEvent('started', eventData);\n    }\n    /**\n     * [pause stops the timer without resetting the counters. The timer it can be restarted with start function.\n     * Dispatch paused event]\n     * @return {type} [description]\n     */\n\n\n    function pause() {\n      stopTimer();\n      paused = true;\n      dispatchEvent('paused', eventData);\n    }\n    /**\n     * [addEventListener Adds event listener to the timer]\n     * @param {string} eventType      [event to listen]\n     * @param {function} listener   [the event listener function]\n     */\n\n\n    function addEventListener(eventType, listener) {\n      eventEmitter.on(eventType, listener);\n    }\n    /**\n     * [removeEventListener Removes event listener to the timer]\n     * @param  {string} eventType    [event to remove listener]\n     * @param  {function} listener [listener to remove]\n     */\n\n\n    function removeEventListener(eventType, listener) {\n      eventEmitter.removeListener(eventType, listener);\n    }\n    /**\n     * [removeAllEventListeners Removes all events listeners for the given type, no type to remove all types]\n     * @param  {string} [eventType]  [event to remove listener]\n     */\n\n\n    function removeAllEventListeners(eventType) {\n      eventEmitter.removeAllListeners(eventType);\n    }\n    /**\n     * [dispatchEvent dispatches an event]\n     * @param  {string} eventType [event to dispatch]\n     * @param data\n     */\n\n\n    function dispatchEvent(eventType, data) {\n      eventEmitter.emit(eventType, data);\n    }\n    /**\n     * [isRunning return true if the timer is running]\n     * @return {Boolean}\n     */\n\n\n    function isRunning() {\n      return running;\n    }\n    /**\n     * [isPaused returns true if the timer is paused]\n     * @return {Boolean}\n     */\n\n\n    function isPaused() {\n      return paused;\n    }\n    /**\n     * [getTimeValues returns the counter with the current timer values]\n     * @return {TimeCounter}\n     */\n\n\n    function getTimeValues() {\n      return counters;\n    }\n    /**\n     * [getTotalTimeValues returns the counter with the current timer total values]\n     * @return {TimeCounter}\n     */\n\n\n    function getTotalTimeValues() {\n      return totalCounters;\n    }\n    /**\n     * [getConfig returns the configuration parameters]\n     * @return {type}\n     */\n\n\n    function getConfig() {\n      return timerConfig;\n    }\n    /**\n     * Public API\n     * Definition of Timer instance public functions\n     */\n\n\n    if (typeof this !== 'undefined') {\n      this.start = start;\n      this.pause = pause;\n      this.stop = stop;\n      this.reset = reset;\n      this.isRunning = isRunning;\n      this.isPaused = isPaused;\n      this.getTimeValues = getTimeValues;\n      this.getTotalTimeValues = getTotalTimeValues;\n      this.getConfig = getConfig;\n      this.addEventListener = addEventListener;\n      this.on = addEventListener;\n      this.removeEventListener = removeEventListener;\n      this.removeAllEventListeners = removeAllEventListeners;\n      this.off = removeEventListener;\n    }\n  }\n\n  exports.Timer = Timer;\n  exports[\"default\"] = Timer;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWFzeXRpbWVyLmpzL2Rpc3QvZWFzeXRpbWVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDMEc7QUFDNUcsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyx3QkFBd0I7QUFDdEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixVQUFVO0FBQzFCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Vhc3l0aW1lci5qcy9kaXN0L2Vhc3l0aW1lci5qcz8zODQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZWFzeXRpbWVyLmpzXG4gKiBHZW5lcmF0ZWQ6IDIwMjItMDgtMjNcbiAqIFZlcnNpb246IDQuNS40XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5lYXN5dGltZXIgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9LCBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0UGFkZGluZyhzdHJpbmcsIHBhZExlbmd0aCwgY2hhcmFjdGVyKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNoYXJhY3RlcnMgPSAnJztcbiAgICBzdHJpbmcgPSB0eXBlb2Ygc3RyaW5nID09PSAnbnVtYmVyJyA/IFN0cmluZyhzdHJpbmcpIDogc3RyaW5nO1xuXG4gICAgaWYgKHN0cmluZy5sZW5ndGggPiBwYWRMZW5ndGgpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhZExlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICBjaGFyYWN0ZXJzICs9IFN0cmluZyhjaGFyYWN0ZXIpO1xuICAgIH1cblxuICAgIHJldHVybiAoY2hhcmFjdGVycyArIHN0cmluZykuc2xpY2UoLWNoYXJhY3RlcnMubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRpbWVDb3VudGVyKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuICAvKipcbiAgICogW3RvU3RyaW5nIGNvbnZlcnQgdGhlIGNvdW50ZWQgdmFsdWVzIG9uIGEgc3RyaW5nXVxuICAgKiBAcGFyYW0gIHthcnJheX0gdW5pdHMgICAgICAgICAgIFthcnJheSB3aXRoIHRoZSB1bml0cyB0byBkaXNwbGF5XVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgICAgICBbc2VwYXJhdG9yIG9mIHRoZSB1bml0c11cbiAgICogQHBhcmFtICB7bnVtYmVyfSBsZWZ0WmVyb1BhZGRpbmcgW251bWJlciBvZiB6ZXJvIHBhZGRpbmddXG4gICAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICAgICAgIFtyZXN1bHQgc3RyaW5nXVxuICAgKi9cblxuXG4gIFRpbWVDb3VudGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdW5pdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFsnaG91cnMnLCAnbWludXRlcycsICdzZWNvbmRzJ107XG4gICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJzonO1xuICAgIHZhciBsZWZ0WmVyb1BhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDI7XG4gICAgdW5pdHMgPSB1bml0cyB8fCBbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddO1xuICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnOic7XG4gICAgbGVmdFplcm9QYWRkaW5nID0gbGVmdFplcm9QYWRkaW5nIHx8IDI7XG4gICAgdmFyIGFycmF5VGltZSA9IFtdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHVuaXRzLmxlbmd0aDsgaSA9IGkgKyAxKSB7XG4gICAgICBpZiAodGhpc1t1bml0c1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodW5pdHNbaV0gPT09ICdzZWNvbmRUZW50aHMnKSB7XG4gICAgICAgICAgYXJyYXlUaW1lLnB1c2godGhpc1t1bml0c1tpXV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5VGltZS5wdXNoKGxlZnRQYWRkaW5nKHRoaXNbdW5pdHNbaV1dLCBsZWZ0WmVyb1BhZGRpbmcsICcwJykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5VGltZS5qb2luKHNlcGFyYXRvcik7XG4gIH07XG4gIC8qKlxuICAgKiBbcmVzZXQgcmVzZXQgY291bnRlcl1cbiAgICovXG5cblxuICBUaW1lQ291bnRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWNvbmRUZW50aHMgPSAwO1xuICAgIHRoaXMuc2Vjb25kcyA9IDA7XG4gICAgdGhpcy5taW51dGVzID0gMDtcbiAgICB0aGlzLmhvdXJzID0gMDtcbiAgICB0aGlzLmRheXMgPSAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzW2V2ZW50XSkpIHtcbiAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzW2V2ZW50XSkpIHtcbiAgICAgIHZhciBldmVudEluZGV4ID0gdGhpcy5ldmVudHNbZXZlbnRdLmluZGV4T2YobGlzdGVuZXIpO1xuXG4gICAgICBpZiAoZXZlbnRJbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XS5zcGxpY2UoZXZlbnRJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudHNbZXZlbnRdKSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnRdID0gW107XG4gICAgfVxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudHNbZXZlbnRdKSkge1xuICAgICAgdGhpcy5ldmVudHNbZXZlbnRdLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseShfdGhpczIsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEdlbmVyYWwgZnVuY3Rpb25zLCB2YXJpYWJsZXMgYW5kIGNvbnN0YW50c1xuICAgKi9cblxuICB2YXIgU0VDT05EX1RFTlRIU19QRVJfU0VDT05EID0gMTA7XG4gIHZhciBTRUNPTkRTX1BFUl9NSU5VVEUgPSA2MDtcbiAgdmFyIE1JTlVURVNfUEVSX0hPVVIgPSA2MDtcbiAgdmFyIEhPVVJTX1BFUl9EQVkgPSAyNDtcbiAgdmFyIFNFQ09ORF9URU5USFNfUE9TSVRJT04gPSAwO1xuICB2YXIgU0VDT05EU19QT1NJVElPTiA9IDE7XG4gIHZhciBNSU5VVEVTX1BPU0lUSU9OID0gMjtcbiAgdmFyIEhPVVJTX1BPU0lUSU9OID0gMztcbiAgdmFyIERBWVNfUE9TSVRJT04gPSA0O1xuICB2YXIgU0VDT05EX1RFTlRIUyA9ICdzZWNvbmRUZW50aHMnO1xuICB2YXIgU0VDT05EUyA9ICdzZWNvbmRzJztcbiAgdmFyIE1JTlVURVMgPSAnbWludXRlcyc7XG4gIHZhciBIT1VSUyA9ICdob3Vycyc7XG4gIHZhciBEQVlTID0gJ2RheXMnO1xuICB2YXIgVkFMSURfSU5QVVRfVkFMVUVTID0gW1NFQ09ORF9URU5USFMsIFNFQ09ORFMsIE1JTlVURVMsIEhPVVJTLCBEQVlTXTtcbiAgdmFyIHVuaXRzSW5NaWxsaXNlY29uZHMgPSB7XG4gICAgc2Vjb25kVGVudGhzOiAxMDAsXG4gICAgc2Vjb25kczogMTAwMCxcbiAgICBtaW51dGVzOiA2MDAwMCxcbiAgICBob3VyczogMzYwMDAwMCxcbiAgICBkYXlzOiA4NjQwMDAwMFxuICB9O1xuICB2YXIgZ3JvdXBlZFVuaXRzID0ge1xuICAgIHNlY29uZFRlbnRoczogU0VDT05EX1RFTlRIU19QRVJfU0VDT05ELFxuICAgIHNlY29uZHM6IFNFQ09ORFNfUEVSX01JTlVURSxcbiAgICBtaW51dGVzOiBNSU5VVEVTX1BFUl9IT1VSLFxuICAgIGhvdXJzOiBIT1VSU19QRVJfREFZXG4gIH07XG5cbiAgZnVuY3Rpb24gbW9kKG51bWJlciwgbW9kdWxlKSB7XG4gICAgcmV0dXJuIChudW1iZXIgJSBtb2R1bGUgKyBtb2R1bGUpICUgbW9kdWxlO1xuICB9XG4gIC8qKlxuICAgKiBbVGltZXIgVGltZXIvQ2hyb25vbWV0ZXIvQ291bnRkb3duIGNvbXBhdGlibGUgd2l0aCBBTUQgYW5kIE5vZGVKUy5cbiAgICogQ2FuIHVwZGF0ZSB0aW1lIHZhbHVlcyB3aXRoIGRpZmZlcmVudCB0aW1lIGludGVydmFsczogdGVudGggb2Ygc2Vjb25kcyxcbiAgICogc2Vjb25kcywgbWludXRlcyBhbmQgaG91cnMuXVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIFRpbWVyKCkge1xuICAgIHZhciBkZWZhdWx0UGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgIC8qXG4gICAgKiBQUklWQVRFIHZhcmlhYmxlcyBhbmQgRnVuY3Rpb25zXG4gICAgKi9cbiAgICB2YXIgY291bnRlcnMgPSBuZXcgVGltZUNvdW50ZXIoKTtcbiAgICB2YXIgdG90YWxDb3VudGVycyA9IG5ldyBUaW1lQ291bnRlcigpO1xuICAgIHZhciBpbnRlcnZhbElkO1xuICAgIHZhciBldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgdmFyIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gICAgdmFyIHByZWNpc2lvbjtcbiAgICB2YXIgdGltZXJUeXBlRmFjdG9yO1xuICAgIHZhciBjdXN0b21DYWxsYmFjaztcbiAgICB2YXIgdGltZXJDb25maWcgPSB7fTtcbiAgICB2YXIgY3VycmVudFBhcmFtcztcbiAgICB2YXIgdGFyZ2V0VmFsdWVzO1xuICAgIHZhciBzdGFydFZhbHVlcztcbiAgICB2YXIgY291bnRkb3duO1xuICAgIHZhciBzdGFydGluZ0RhdGU7XG4gICAgdmFyIHRhcmdldERhdGU7XG4gICAgdmFyIGV2ZW50RGF0YSA9IHtcbiAgICAgIGRldGFpbDoge1xuICAgICAgICB0aW1lcjogdGhpc1xuICAgICAgfVxuICAgIH07XG4gICAgc2V0UGFyYW1zKGRlZmF1bHRQYXJhbXMpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ291bnRlcnMocHJlY2lzaW9uLCByb3VuZGVkVmFsdWUpIHtcbiAgICAgIHZhciB1bml0c1Blckdyb3VwID0gZ3JvdXBlZFVuaXRzW3ByZWNpc2lvbl07XG4gICAgICB0b3RhbENvdW50ZXJzW3ByZWNpc2lvbl0gPSByb3VuZGVkVmFsdWU7XG5cbiAgICAgIGlmIChwcmVjaXNpb24gPT09IERBWVMpIHtcbiAgICAgICAgY291bnRlcnNbcHJlY2lzaW9uXSA9IE1hdGguYWJzKHJvdW5kZWRWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHJvdW5kZWRWYWx1ZSA+PSAwKSB7XG4gICAgICAgIGNvdW50ZXJzW3ByZWNpc2lvbl0gPSBtb2Qocm91bmRlZFZhbHVlLCB1bml0c1Blckdyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZXJzW3ByZWNpc2lvbl0gPSBtb2QodW5pdHNQZXJHcm91cCAtIG1vZChyb3VuZGVkVmFsdWUsIHVuaXRzUGVyR3JvdXApLCB1bml0c1Blckdyb3VwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVEYXlzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdXBkYXRlVW5pdEJ5UHJlY2lzaW9uKHZhbHVlLCBEQVlTKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3Vycyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVVuaXRCeVByZWNpc2lvbih2YWx1ZSwgSE9VUlMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1pbnV0ZXModmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVVbml0QnlQcmVjaXNpb24odmFsdWUsIE1JTlVURVMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY29uZHModmFsdWUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVVbml0QnlQcmVjaXNpb24odmFsdWUsIFNFQ09ORFMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY29uZFRlbnRocyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVwZGF0ZVVuaXRCeVByZWNpc2lvbih2YWx1ZSwgU0VDT05EX1RFTlRIUyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlVW5pdEJ5UHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pIHtcbiAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdG90YWxDb3VudGVyc1twcmVjaXNpb25dO1xuICAgICAgdXBkYXRlQ291bnRlcnMocHJlY2lzaW9uLCBjYWxjdWxhdGVJbnRlZ2VyVW5pdFF1b3RpZW50KHZhbHVlLCB1bml0c0luTWlsbGlzZWNvbmRzW3ByZWNpc2lvbl0pKTtcbiAgICAgIHJldHVybiB0b3RhbENvdW50ZXJzW3ByZWNpc2lvbl0gIT09IHByZXZpb3VzVmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcFRpbWVyQW5kUmVzZXRDb3VudGVycygpIHtcbiAgICAgIHN0b3BUaW1lcigpO1xuICAgICAgcmVzZXRDb3VudGVycygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0b3BUaW1lcigpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICBpbnRlcnZhbElkID0gdW5kZWZpbmVkO1xuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGFyYW1zQW5kU3RhcnRUaW1lcihwYXJhbXMpIHtcbiAgICAgIGlmICghaXNQYXVzZWQoKSkge1xuICAgICAgICBzZXRQYXJhbXMocGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0aW5nRGF0ZSA9IGNhbGN1bGF0ZVN0YXJ0aW5nRGF0ZSgpO1xuICAgICAgICB0YXJnZXRWYWx1ZXMgPSBzZXRUYXJnZXQoY3VycmVudFBhcmFtcy50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBzdGFydFRpbWVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRUaW1lcigpIHtcbiAgICAgIHZhciBpbnRlcnZhbCA9IHVuaXRzSW5NaWxsaXNlY29uZHNbcHJlY2lzaW9uXTtcblxuICAgICAgaWYgKGlzVGFyZ2V0QWNoaWV2ZWQocm91bmRUaW1lc3RhbXAoRGF0ZS5ub3coKSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHVwZGF0ZVRpbWVyQW5kRGlzcGF0Y2hFdmVudHMsIGludGVydmFsKTtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU3RhcnRpbmdEYXRlKCkge1xuICAgICAgcmV0dXJuIHJvdW5kVGltZXN0YW1wKERhdGUubm93KCkpIC0gdG90YWxDb3VudGVycy5zZWNvbmRUZW50aHMgKiB1bml0c0luTWlsbGlzZWNvbmRzW1NFQ09ORF9URU5USFNdICogdGltZXJUeXBlRmFjdG9yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRpbWVyQW5kRGlzcGF0Y2hFdmVudHMoKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSByb3VuZFRpbWVzdGFtcChEYXRlLm5vdygpKTtcbiAgICAgIHZhciB2YWx1ZXNVcGRhdGVkID0gdXBkYXRlVGltZXIoKTtcbiAgICAgIGRpc3BhdGNoRXZlbnRzKHZhbHVlc1VwZGF0ZWQpO1xuICAgICAgY3VzdG9tQ2FsbGJhY2soZXZlbnREYXRhLmRldGFpbC50aW1lcik7XG5cbiAgICAgIGlmIChpc1RhcmdldEFjaGlldmVkKGN1cnJlbnRUaW1lKSkge1xuICAgICAgICBzdG9wKCk7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoJ3RhcmdldEFjaGlldmVkJywgZXZlbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVUaW1lcigpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogcm91bmRUaW1lc3RhbXAoRGF0ZS5ub3coKSk7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSB0aW1lclR5cGVGYWN0b3IgPiAwID8gY3VycmVudFRpbWUgLSBzdGFydGluZ0RhdGUgOiBzdGFydGluZ0RhdGUgLSBjdXJyZW50VGltZTtcbiAgICAgIHZhciB2YWx1ZXNVcGRhdGVkID0ge307XG4gICAgICB2YWx1ZXNVcGRhdGVkW1NFQ09ORF9URU5USFNdID0gdXBkYXRlU2Vjb25kVGVudGhzKGVsYXBzZWRUaW1lKTtcbiAgICAgIHZhbHVlc1VwZGF0ZWRbU0VDT05EU10gPSB1cGRhdGVTZWNvbmRzKGVsYXBzZWRUaW1lKTtcbiAgICAgIHZhbHVlc1VwZGF0ZWRbTUlOVVRFU10gPSB1cGRhdGVNaW51dGVzKGVsYXBzZWRUaW1lKTtcbiAgICAgIHZhbHVlc1VwZGF0ZWRbSE9VUlNdID0gdXBkYXRlSG91cnMoZWxhcHNlZFRpbWUpO1xuICAgICAgdmFsdWVzVXBkYXRlZFtEQVlTXSA9IHVwZGF0ZURheXMoZWxhcHNlZFRpbWUpO1xuICAgICAgcmV0dXJuIHZhbHVlc1VwZGF0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRUaW1lc3RhbXAodGltZXN0YW1wKSB7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcih0aW1lc3RhbXAgLyB1bml0c0luTWlsbGlzZWNvbmRzW3ByZWNpc2lvbl0pICogdW5pdHNJbk1pbGxpc2Vjb25kc1twcmVjaXNpb25dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzKHZhbHVlc1VwZGF0ZWQpIHtcbiAgICAgIGlmICh2YWx1ZXNVcGRhdGVkW1NFQ09ORF9URU5USFNdKSB7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoJ3NlY29uZFRlbnRoc1VwZGF0ZWQnLCBldmVudERhdGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWVzVXBkYXRlZFtTRUNPTkRTXSkge1xuICAgICAgICBkaXNwYXRjaEV2ZW50KCdzZWNvbmRzVXBkYXRlZCcsIGV2ZW50RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXNVcGRhdGVkW01JTlVURVNdKSB7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoJ21pbnV0ZXNVcGRhdGVkJywgZXZlbnREYXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlc1VwZGF0ZWRbSE9VUlNdKSB7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoJ2hvdXJzVXBkYXRlZCcsIGV2ZW50RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXNVcGRhdGVkW0RBWVNdKSB7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoJ2RheXNVcGRhdGVkJywgZXZlbnREYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1RhcmdldEFjaGlldmVkKGN1cnJlbnREYXRlKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0VmFsdWVzIGluc3RhbmNlb2YgQXJyYXkgJiYgY3VycmVudERhdGUgPj0gdGFyZ2V0RGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldENvdW50ZXJzKCkge1xuICAgICAgY291bnRlcnMucmVzZXQoKTtcbiAgICAgIHRvdGFsQ291bnRlcnMucmVzZXQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRQYXJhbXMocGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICBwcmVjaXNpb24gPSBjaGVja1ByZWNpc2lvbihwYXJhbXMucHJlY2lzaW9uKTtcbiAgICAgIGN1c3RvbUNhbGxiYWNrID0gdHlwZW9mIHBhcmFtcy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmFtcy5jYWxsYmFjayA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgY291bnRkb3duID0gcGFyYW1zLmNvdW50ZG93biA9PT0gdHJ1ZTtcbiAgICAgIHRpbWVyVHlwZUZhY3RvciA9IGNvdW50ZG93biA9PT0gdHJ1ZSA/IC0xIDogMTtcblxuICAgICAgaWYgKF90eXBlb2YocGFyYW1zLnN0YXJ0VmFsdWVzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgc2V0U3RhcnRWYWx1ZXMocGFyYW1zLnN0YXJ0VmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VmFsdWVzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc3RhcnRpbmdEYXRlID0gY2FsY3VsYXRlU3RhcnRpbmdEYXRlKCk7XG4gICAgICB1cGRhdGVUaW1lcigpO1xuXG4gICAgICBpZiAoX3R5cGVvZihwYXJhbXMudGFyZ2V0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGFyZ2V0VmFsdWVzID0gc2V0VGFyZ2V0KHBhcmFtcy50YXJnZXQpO1xuICAgICAgfSBlbHNlIGlmIChjb3VudGRvd24pIHtcbiAgICAgICAgcGFyYW1zLnRhcmdldCA9IHtcbiAgICAgICAgICBzZWNvbmRzOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldFZhbHVlcyA9IHNldFRhcmdldChwYXJhbXMudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFZhbHVlcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRpbWVyQ29uZmlnID0ge1xuICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgY2FsbGJhY2s6IGN1c3RvbUNhbGxiYWNrLFxuICAgICAgICBjb3VudGRvd246IF90eXBlb2YocGFyYW1zKSA9PT0gJ29iamVjdCcgJiYgcGFyYW1zLmNvdW50ZG93biA9PT0gdHJ1ZSxcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRWYWx1ZXMsXG4gICAgICAgIHN0YXJ0VmFsdWVzOiBzdGFydFZhbHVlc1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnRQYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tQcmVjaXNpb24ocHJlY2lzaW9uKSB7XG4gICAgICBwcmVjaXNpb24gPSB0eXBlb2YgcHJlY2lzaW9uID09PSAnc3RyaW5nJyA/IHByZWNpc2lvbiA6IFNFQ09ORFM7XG5cbiAgICAgIGlmICghaXNWYWxpZElucHV0VmFsdWUocHJlY2lzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBwcmVjaXNpb24gcGFyYW1ldGVyOiBcIi5jb25jYXQocHJlY2lzaW9uLCBcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZVwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVjaXNpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZElucHV0VmFsdWUodmFsdWUpIHtcbiAgICAgIHJldHVybiBWQUxJRF9JTlBVVF9WQUxVRVMuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdJbnB1dFZhbHVlcyhpbnB1dFZhbHVlcykge1xuICAgICAgdmFyIHZhbHVlcztcblxuICAgICAgaWYgKF90eXBlb2YoaW5wdXRWYWx1ZXMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaW5wdXRWYWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGlmIChpbnB1dFZhbHVlcy5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgc2l6ZSBub3QgdmFsaWQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZXMgPSBpbnB1dFZhbHVlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciB2YWx1ZSBpbiBpbnB1dFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKFZBTElEX0lOUFVUX1ZBTFVFUy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gc3RhcnRWYWx1ZXMgb3IgdGFyZ2V0IHBhcmFtZXRlcjogXCIuY29uY2F0KHZhbHVlLCBcIiBpcyBub3QgYSB2YWxpZCBpbnB1dCB2YWx1ZVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFsdWVzID0gW2lucHV0VmFsdWVzLnNlY29uZFRlbnRocyB8fCAwLCBpbnB1dFZhbHVlcy5zZWNvbmRzIHx8IDAsIGlucHV0VmFsdWVzLm1pbnV0ZXMgfHwgMCwgaW5wdXRWYWx1ZXMuaG91cnMgfHwgMCwgaW5wdXRWYWx1ZXMuZGF5cyB8fCAwXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNlY29uZFRlbnRocyA9IHZhbHVlc1tTRUNPTkRfVEVOVEhTX1BPU0lUSU9OXTtcbiAgICAgIHZhciBzZWNvbmRzID0gdmFsdWVzW1NFQ09ORFNfUE9TSVRJT05dICsgY2FsY3VsYXRlSW50ZWdlclVuaXRRdW90aWVudChzZWNvbmRUZW50aHMsIFNFQ09ORF9URU5USFNfUEVSX1NFQ09ORCk7XG4gICAgICB2YXIgbWludXRlcyA9IHZhbHVlc1tNSU5VVEVTX1BPU0lUSU9OXSArIGNhbGN1bGF0ZUludGVnZXJVbml0UXVvdGllbnQoc2Vjb25kcywgU0VDT05EU19QRVJfTUlOVVRFKTtcbiAgICAgIHZhciBob3VycyA9IHZhbHVlc1tIT1VSU19QT1NJVElPTl0gKyBjYWxjdWxhdGVJbnRlZ2VyVW5pdFF1b3RpZW50KG1pbnV0ZXMsIE1JTlVURVNfUEVSX0hPVVIpO1xuICAgICAgdmFyIGRheXMgPSB2YWx1ZXNbREFZU19QT1NJVElPTl0gKyBjYWxjdWxhdGVJbnRlZ2VyVW5pdFF1b3RpZW50KGhvdXJzLCBIT1VSU19QRVJfREFZKTtcbiAgICAgIHZhbHVlc1tTRUNPTkRfVEVOVEhTX1BPU0lUSU9OXSA9IHNlY29uZFRlbnRocyAlIFNFQ09ORF9URU5USFNfUEVSX1NFQ09ORDtcbiAgICAgIHZhbHVlc1tTRUNPTkRTX1BPU0lUSU9OXSA9IHNlY29uZHMgJSBTRUNPTkRTX1BFUl9NSU5VVEU7XG4gICAgICB2YWx1ZXNbTUlOVVRFU19QT1NJVElPTl0gPSBtaW51dGVzICUgTUlOVVRFU19QRVJfSE9VUjtcbiAgICAgIHZhbHVlc1tIT1VSU19QT1NJVElPTl0gPSBob3VycyAlIEhPVVJTX1BFUl9EQVk7XG4gICAgICB2YWx1ZXNbREFZU19QT1NJVElPTl0gPSBkYXlzO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVJbnRlZ2VyVW5pdFF1b3RpZW50KHVuaXQsIGRpdmlzb3IpIHtcbiAgICAgIHZhciBxdW90aWVudCA9IHVuaXQgLyBkaXZpc29yO1xuICAgICAgcmV0dXJuIHF1b3RpZW50IDwgMCA/IE1hdGguY2VpbChxdW90aWVudCkgOiBNYXRoLmZsb29yKHF1b3RpZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUYXJnZXQoaW5wdXRUYXJnZXQpIHtcbiAgICAgIGlmICghaW5wdXRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXRWYWx1ZXMgPSBjb25maWdJbnB1dFZhbHVlcyhpbnB1dFRhcmdldCk7XG4gICAgICB2YXIgdGFyZ2V0Q291bnRlciA9IGNhbGN1bGF0ZVRvdGFsQ291bnRlckZyb21WYWx1ZXModGFyZ2V0VmFsdWVzKTtcbiAgICAgIHRhcmdldERhdGUgPSBzdGFydGluZ0RhdGUgKyB0YXJnZXRDb3VudGVyLnNlY29uZFRlbnRocyAqIHVuaXRzSW5NaWxsaXNlY29uZHNbU0VDT05EX1RFTlRIU10gKiB0aW1lclR5cGVGYWN0b3I7XG4gICAgICByZXR1cm4gdGFyZ2V0VmFsdWVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFN0YXJ0VmFsdWVzKGlucHV0U3RhcnRWYWx1ZXMpIHtcbiAgICAgIHN0YXJ0VmFsdWVzID0gY29uZmlnSW5wdXRWYWx1ZXMoaW5wdXRTdGFydFZhbHVlcyk7XG4gICAgICBjb3VudGVycy5zZWNvbmRUZW50aHMgPSBzdGFydFZhbHVlc1tTRUNPTkRfVEVOVEhTX1BPU0lUSU9OXTtcbiAgICAgIGNvdW50ZXJzLnNlY29uZHMgPSBzdGFydFZhbHVlc1tTRUNPTkRTX1BPU0lUSU9OXTtcbiAgICAgIGNvdW50ZXJzLm1pbnV0ZXMgPSBzdGFydFZhbHVlc1tNSU5VVEVTX1BPU0lUSU9OXTtcbiAgICAgIGNvdW50ZXJzLmhvdXJzID0gc3RhcnRWYWx1ZXNbSE9VUlNfUE9TSVRJT05dO1xuICAgICAgY291bnRlcnMuZGF5cyA9IHN0YXJ0VmFsdWVzW0RBWVNfUE9TSVRJT05dO1xuICAgICAgdG90YWxDb3VudGVycyA9IGNhbGN1bGF0ZVRvdGFsQ291bnRlckZyb21WYWx1ZXMoc3RhcnRWYWx1ZXMsIHRvdGFsQ291bnRlcnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVRvdGFsQ291bnRlckZyb21WYWx1ZXModmFsdWVzLCBvdXRwdXRDb3VudGVyKSB7XG4gICAgICB2YXIgdG90YWwgPSBvdXRwdXRDb3VudGVyIHx8IHt9O1xuICAgICAgdG90YWwuZGF5cyA9IHZhbHVlc1tEQVlTX1BPU0lUSU9OXTtcbiAgICAgIHRvdGFsLmhvdXJzID0gdG90YWwuZGF5cyAqIEhPVVJTX1BFUl9EQVkgKyB2YWx1ZXNbSE9VUlNfUE9TSVRJT05dO1xuICAgICAgdG90YWwubWludXRlcyA9IHRvdGFsLmhvdXJzICogTUlOVVRFU19QRVJfSE9VUiArIHZhbHVlc1tNSU5VVEVTX1BPU0lUSU9OXTtcbiAgICAgIHRvdGFsLnNlY29uZHMgPSB0b3RhbC5taW51dGVzICogU0VDT05EU19QRVJfTUlOVVRFICsgdmFsdWVzW1NFQ09ORFNfUE9TSVRJT05dO1xuICAgICAgdG90YWwuc2Vjb25kVGVudGhzID0gdG90YWwuc2Vjb25kcyAqIFNFQ09ORF9URU5USFNfUEVSX1NFQ09ORCArIHZhbHVlc1tbU0VDT05EX1RFTlRIU19QT1NJVElPTl1dO1xuICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFBVQkxJQyBmdW5jdGlvbnNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFtzdG9wIHN0b3BzIHRoZSB0aW1lciBhbmQgcmVzZXRzIHRoZSBjb3VudGVycy4gRGlzcGF0Y2ggc3RvcHBlZCBldmVudF1cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHN0b3BUaW1lckFuZFJlc2V0Q291bnRlcnMoKTtcbiAgICAgIGRpc3BhdGNoRXZlbnQoJ3N0b3BwZWQnLCBldmVudERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbc3RvcCBzdG9wcyBhbmQgc3RhcnRzIHRoZSB0aW1lci4gRGlzcGF0Y2ggc3RvcHBlZCBldmVudF1cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBzdG9wVGltZXJBbmRSZXNldENvdW50ZXJzKCk7XG4gICAgICBzZXRQYXJhbXNBbmRTdGFydFRpbWVyKGN1cnJlbnRQYXJhbXMpO1xuICAgICAgZGlzcGF0Y2hFdmVudCgncmVzZXQnLCBldmVudERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbc3RhcnQgc3RhcnRzIHRoZSB0aW1lciBjb25maWd1cmVkIGJ5IHRoZSBwYXJhbXMgb2JqZWN0LiBEaXNwYXRjaCBzdGFydGVkIGV2ZW50XVxuICAgICAqIEBwYXJhbSAge29iamVjdH0gcGFyYW1zIFtDb25maWd1cmF0aW9uIHBhcmFtZXRlcnNdXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICBwYXJhbXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdFBhcmFtcyksIHBhcmFtcyk7XG5cbiAgICAgIGlmIChpc1J1bm5pbmcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNldFBhcmFtc0FuZFN0YXJ0VGltZXIocGFyYW1zKTtcbiAgICAgIGRpc3BhdGNoRXZlbnQoJ3N0YXJ0ZWQnLCBldmVudERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbcGF1c2Ugc3RvcHMgdGhlIHRpbWVyIHdpdGhvdXQgcmVzZXR0aW5nIHRoZSBjb3VudGVycy4gVGhlIHRpbWVyIGl0IGNhbiBiZSByZXN0YXJ0ZWQgd2l0aCBzdGFydCBmdW5jdGlvbi5cbiAgICAgKiBEaXNwYXRjaCBwYXVzZWQgZXZlbnRdXG4gICAgICogQHJldHVybiB7dHlwZX0gW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHN0b3BUaW1lcigpO1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIGRpc3BhdGNoRXZlbnQoJ3BhdXNlZCcsIGV2ZW50RGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFthZGRFdmVudExpc3RlbmVyIEFkZHMgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRpbWVyXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgICAgICBbZXZlbnQgdG8gbGlzdGVuXVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyICAgW3RoZSBldmVudCBsaXN0ZW5lciBmdW5jdGlvbl1cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBldmVudEVtaXR0ZXIub24oZXZlbnRUeXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtyZW1vdmVFdmVudExpc3RlbmVyIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIHRpbWVyXVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZXZlbnRUeXBlICAgIFtldmVudCB0byByZW1vdmUgbGlzdGVuZXJdXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IGxpc3RlbmVyIFtsaXN0ZW5lciB0byByZW1vdmVdXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBbcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMgUmVtb3ZlcyBhbGwgZXZlbnRzIGxpc3RlbmVycyBmb3IgdGhlIGdpdmVuIHR5cGUsIG5vIHR5cGUgdG8gcmVtb3ZlIGFsbCB0eXBlc11cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtldmVudFR5cGVdICBbZXZlbnQgdG8gcmVtb3ZlIGxpc3RlbmVyXVxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxFdmVudExpc3RlbmVycyhldmVudFR5cGUpIHtcbiAgICAgIGV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnRUeXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogW2Rpc3BhdGNoRXZlbnQgZGlzcGF0Y2hlcyBhbiBldmVudF1cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50VHlwZSBbZXZlbnQgdG8gZGlzcGF0Y2hdXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudFR5cGUsIGRhdGEpIHtcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50VHlwZSwgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtpc1J1bm5pbmcgcmV0dXJuIHRydWUgaWYgdGhlIHRpbWVyIGlzIHJ1bm5pbmddXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gaXNSdW5uaW5nKCkge1xuICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtpc1BhdXNlZCByZXR1cm5zIHRydWUgaWYgdGhlIHRpbWVyIGlzIHBhdXNlZF1cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBpc1BhdXNlZCgpIHtcbiAgICAgIHJldHVybiBwYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtnZXRUaW1lVmFsdWVzIHJldHVybnMgdGhlIGNvdW50ZXIgd2l0aCB0aGUgY3VycmVudCB0aW1lciB2YWx1ZXNdXG4gICAgICogQHJldHVybiB7VGltZUNvdW50ZXJ9XG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGdldFRpbWVWYWx1ZXMoKSB7XG4gICAgICByZXR1cm4gY291bnRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtnZXRUb3RhbFRpbWVWYWx1ZXMgcmV0dXJucyB0aGUgY291bnRlciB3aXRoIHRoZSBjdXJyZW50IHRpbWVyIHRvdGFsIHZhbHVlc11cbiAgICAgKiBAcmV0dXJuIHtUaW1lQ291bnRlcn1cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZ2V0VG90YWxUaW1lVmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRvdGFsQ291bnRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFtnZXRDb25maWcgcmV0dXJucyB0aGUgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzXVxuICAgICAqIEByZXR1cm4ge3R5cGV9XG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGdldENvbmZpZygpIHtcbiAgICAgIHJldHVybiB0aW1lckNvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGljIEFQSVxuICAgICAqIERlZmluaXRpb24gb2YgVGltZXIgaW5zdGFuY2UgcHVibGljIGZ1bmN0aW9uc1xuICAgICAqL1xuXG5cbiAgICBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLnBhdXNlID0gcGF1c2U7XG4gICAgICB0aGlzLnN0b3AgPSBzdG9wO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0O1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSBpc1J1bm5pbmc7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gaXNQYXVzZWQ7XG4gICAgICB0aGlzLmdldFRpbWVWYWx1ZXMgPSBnZXRUaW1lVmFsdWVzO1xuICAgICAgdGhpcy5nZXRUb3RhbFRpbWVWYWx1ZXMgPSBnZXRUb3RhbFRpbWVWYWx1ZXM7XG4gICAgICB0aGlzLmdldENvbmZpZyA9IGdldENvbmZpZztcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICB0aGlzLm9uID0gYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgICB0aGlzLnJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnM7XG4gICAgICB0aGlzLm9mZiA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5UaW1lciA9IFRpbWVyO1xuICBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IFRpbWVyO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/easytimer.js/dist/easytimer.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./resources/js/auth.js");
/******/ 	
/******/ })()
;